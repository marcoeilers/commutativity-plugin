/// data structures:

// ints: count, add, mult
// something with abstraction?

// bitvector: and, or, xor
// something with abstraction?


/// combinations

// two things protected, ops commute wrt to one but not the other, abstract

/// frameworks

// actors w messages, the message queues are all protected by the lock
// maybe a leader election thing oder

// work share, work steal. or general worker thing.

// ask robert if other stuff like mapreduce
// -> they generally avoid shared memory, makes sense. actors and message passing.

// prodcons: pipeline.


/// story

// almost everything leaks

// subsumes write-conflict-free (venn), which includes embarassingly parallel and mapreduce

// incompleteness: we require everything to commute in any order, incomplete if order is actually limited. e.g. faux-parallel:
// threads are waiting for others to have done something using busy loops
// other example: n threads all do something, then ALL write the same constant as their last action. result will be constant.


/// lucas stuff:
examples are bank account and set, so super basic.

unlike the lucas stuff,
we only look at modifications, not at queries. that's a big difference.

they have stuff like
contains(s, k)
insert(s', k', v')

and then say, well, commutes if k != k'
and sometimes say "asym commutes", which is right movers or whatever.
BUT
we don't have single traces, we don't have right or left movers. is that for a good reason?
is the reason that we need *all* interleavings of some things to have the same result?
vs
showing every trace can be rearranged s.t. it has some form where things are serial, that's not the same right



/// model checking / partial order reduction:
1. we want to be modular. if you're willing to consider all possible interleavings, there is no problem in the first place.
2. TODO christoph.


