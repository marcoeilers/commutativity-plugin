import "library/pair.vpr"
import "library/unit.vpr"
import "library/either.vpr"

domain Nat {
  function nat(i: Int): Nat
  function nat_val(n: Nat): Int

  axiom nat_val_and_equality {
    (forall i: Int :: { nat(i) } nat_val(nat(i)) == (i > 0 ? i : -i))
    &&
    (forall i: Int :: { nat(i) } nat(i) == nat(-i))
    &&
    (forall n: Nat :: { nat_val(n) } nat(nat_val(n)) == n)
    &&
    (forall n: Nat :: { nat_val(n) } nat_val(n) >= 0 )
  }
}

lockType Channel {
  type Either[Nat, Seq[Int]]
  invariant(l, v) = [l.queue |-> ?lp && isList(lp) && v == (right(seqValue(lp)): Either[Nat, Seq[Int]])]
  alpha(v): Either[Nat, Seq[Int]] = v

  actions = [(Prod, Int, unique), (Cons, Unit, unique)]
  
  action Prod(v, arg)
    requires low(arg)
  { (is_right(v) ? (right(Seq(arg) ++ right_val(v)): Either[Nat, Seq[Int]]) : (nat_val(left_val(v)) > 0 ? (left(nat(nat_val(left_val(v)) - 1)): Either[Nat, Seq[Int]]) : (right(Seq[Int]()): Either[Nat, Seq[Int]]))) }

  action Cons(v, arg)
    requires true
  { (is_right(v) ? (|right_val(v)| > 0 ? (right(right_val(v)[..|right_val(v)|-1]): Either[Nat, Seq[Int]]) : (left(nat(0)): Either[Nat, Seq[Int]]) ) : (left(nat(nat_val(left_val(v)) + 1)): Either[Nat, Seq[Int]])) }

  proof commutativity[Prod, Cons](v, arg1, arg2) {
    if (is_right(v) && |right_val(v)| > 0) {
      assert (Seq(arg1) ++ right_val(v))[..|(Seq(arg1) ++ right_val(v))|-1] == (Seq(arg1) ++ (right_val(v)[..|right_val(v)|-1]))
    }
  }
}

lockType Channel2 {
  type Pair[Seq[Int], Either[Nat, Seq[Int]]]
  invariant(l, v) = [l.queue |-> ?lp && isList(lp) && [l.history |-> ?hi && |hi| >= |seqValue(lp)| && hi[..|seqValue(lp)|] == seqValue(lp) && v == pair(hi, right(seqValue(lp))) ]]
  alpha(v): Pair[Seq[Int], Either[Nat, Seq[Int]]] = v

  actions = [(Prod, Int, unique), (Cons, Unit, unique)]

  action Prod(pv, arg)
    requires low(arg)
  { (pair(Seq(arg) ++ fst(pv), let v == (snd(pv)) in
    (is_right(v) ?
      (right(Seq(arg) ++ right_val(v)): Either[Nat, Seq[Int]]) :
      (nat_val(left_val(v)) > 0 ?
        (left(nat(nat_val(left_val(v)) - 1)): Either[Nat, Seq[Int]]) :
        (right(Seq[Int]()): Either[Nat, Seq[Int]])))
    ))}

  action Cons(pv, arg)
    requires true
  {
    (pair(fst(pv), let v == (snd(pv)) in
    (is_right(v) ?
      (|right_val(v)| > 0 ?
        (right(right_val(v)[..|right_val(v)|-1]): Either[Nat, Seq[Int]]) :
        (left(nat(0)): Either[Nat, Seq[Int]]) ) :
      (left(nat(nat_val(left_val(v)) + 1)): Either[Nat, Seq[Int]]))
    ))
  }

  proof commutativity[Prod, Cons](pv, arg1, arg2) {
    var v: Either[Nat, Seq[Int]]
    v := snd(pv)
    if (is_right(v) && |right_val(v)| > 0) {
      assert (Seq(arg1) ++ right_val(v))[..|(Seq(arg1) ++ right_val(v))|-1] == (Seq(arg1) ++ (right_val(v)[..|right_val(v)|-1]))
    }
    //if (is_left(v)) {
    //  assert false
    //}
  }
}

predicate isList(r: Ref)
function seqValue(r: Ref): Seq[Int]
  requires acc(isList(r), 1/8)

method emptyList() returns (r: Ref)
  ensures isList(r) && seqValue(r) == Seq[Int]()

method length(l: Ref) returns (r: Int)
  requires acc(isList(l), 1/2)
  ensures acc(isList(l), 1/2) && r == |seqValue(l)|

method enqueue(l: Ref, i: Int)
  requires isList(l)
  ensures isList(l) && seqValue(l) == Seq(i) ++ old(seqValue(l))

method dequeue(l: Ref) returns (r: Int)
  requires isList(l) && |seqValue(l)| > 0
  ensures isList(l) && seqValue(l) == old(seqValue(l)[..|seqValue(l)|-1]) 
  ensures r == old(seqValue(l)[|seqValue(l)|-1])

field queue: Ref
field history: Seq[Int]


method main(inputs: Seq[Int], secret: Int)
  requires lowEvent && low(inputs)
  ensures true
{
  
  var l : Lock
  l := newLock[Channel](queue)
  var list: Ref
  list := emptyList()
  l.queue := list
  share[Channel](l, (let es == (Seq[Int]()) in (  right( es ) : Either[Nat, Seq[Int]] )) )
  var cons : Thread
  var prod : Thread
  prod := fork producer(inputs, l, secret)
  cons := fork consumer(l, |inputs|, secret)
}


method producer(inputs: Seq[Int], l: Lock, secret: Int)
  requires lowEvent && low(inputs) && lock[Channel](l, 1/2) && guard[Channel,Prod](l)
  ensures lock[Channel](l, 1/2)
{
  var i : Int := 0
  while (i < |inputs|) 
    invariant i >= 0 && i <= |inputs| && low(i) && lock[Channel](l, 1/2) && guard[Channel,Prod](l)
  {
    var newVal: Int
    newVal  := compute1(inputs[i], secret)
    acquire[Channel](l)
    
    enqueue(l.queue, newVal)
    
    release[Channel](l, Prod(newVal))
    i := i + 1
  }
}

method consumer(l: Lock, n: Int, secret: Int)
  requires lowEvent && n >= 0 && low(n) && lock[Channel](l, 1/2) && guard[Channel,Cons](l)
  ensures lock[Channel](l, 1/2)
{
  var i : Int := 0
  var res : Int
  res := 0
  while (i < n)
    invariant i >= 0 && i <= n && low(i) && low(res) && lock[Channel](l, 1/2) && guard[Channel,Cons](l)
  {
    var recVal: Int
    acquire[Channel](l)
    var len : Int
    len := length(l.queue)
    while (len == 0)
      invariant [l.queue |-> ?lp && isList(lp) && len == |seqValue(lp)| && lock[Channel](l, 1/4) && locked[Channel](l, (right(seqValue(lp)): Either[Nat, Seq[Int]]))]
    {
      release[Channel](l)
      acquire[Channel](l)
      len := length(l.queue)
    }
    recVal := dequeue(l.queue)
    
    release[Channel](l, Cons(unit()))
    res := aggregate(res, recVal, secret)
    i := i + 1
  }
  print(res)
}


method compute1(val: Int, secret: Int) returns (r1: Int)
  ensures low(val) ==> low(r1)

method aggregate(sum: Int, val: Int, secret: Int) returns (r: Int)
  ensures low(sum) && low(val) ==> low(r)

method print(i: Int)
  requires lowEvent && low(i)
