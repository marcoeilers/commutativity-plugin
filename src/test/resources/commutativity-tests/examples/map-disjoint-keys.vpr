function key_split(i: Int): Bool

method print(mp: Ref)
  requires lowEvent && isMap(mp) && low(mapValue(mp))

domain Pair[T,V] {
  function pair(t: T, v: V) : Pair[T,V]
  function fst(p: Pair[T, V]) : T
  function snd(p: Pair[T, V]) : V

  axiom fst_def {
    forall t: T, v: V :: {fst(pair(t, v))} fst(pair(t, v)) == t
  }  

  axiom snd_def {
    forall t: T, v: V :: {snd(pair(t, v))} snd(pair(t, v)) == v
  }

}

domain Map[T,V] {
  function empty(): Map[T,V]
  function keys(m: Map[T,V]): Set[T]
  function get(m: Map[T,V], k: T) : V
  function put(m: Map[T,V], k: T, v: V): Map[T,V]
  function map_eq(m1: Map[T,V], m2: Map[T,V]) : Bool

  axiom equality_def {
    forall m1: Map[T,V], m2: Map[T,V] :: {map_eq(m1, m2)}
        map_eq(m1, m2) == (keys(m1) == keys(m2) && forall k: T :: k in keys(m1) ==> get(m1, k) == get(m2, k))
  }

  axiom equality_extensional {
    forall m1: Map[T,V], m2: Map[T,V] :: {map_eq(m1, m2)} map_eq(m1, m2) ==> m1 == m2
  }

  axiom empty_def {
    keys(empty()) == Set[T]() 
  }

  axiom put_keys {
    forall m: Map[T,V], k: T, v: V :: {keys(put(m, k, v))} keys(put(m, k, v)) == keys(m) union Set(k) 
  }

  axiom put_get {
    forall m: Map[T,V], k1: T, k2: T, v: V :: {get(put(m, k1, v), k2)} get(put(m, k1, v), k2) == (k1 == k2 ? v : get(m, k2))
  }
}

domain Array {
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function loc_inv_arr(r: Ref): Array
  function loc_inv_index(r: Ref): Int
  
  axiom all_diff {
    forall a: Array, i: Int :: {loc(a, i)} loc_inv_arr(loc(a, i)) == a && loc_inv_index(loc(a, i)) == i
  }

  axiom length_nonneg {
    forall a: Array :: len(a) >= 0
  }
}

lockType MapLock {
  type Map[Int, Int]
  invariant(l, v) = [l.lockMap |-> ?mp && isMap(mp) && v == mapValue(mp)]
  secInvariant(v) = low(v)

  actions = [(Put1, Pair[Int, Int], Int, unique),(Put2, Pair[Int, Int], Int, unique)]
  
  action Put1(v, arg)
    requires low(arg) && key_split(fst(arg))
    ensures true
  { (put(v, fst(arg), snd(arg))), (fst(arg)) }

  action Put2(v, arg)
      requires low(arg) && !key_split(fst(arg))
      ensures true
    { (put(v, fst(arg), snd(arg))), (fst(arg)) }

  proof commutativity[Put1, Put2](v, arg1, arg2) {
    var r1 : Map[Int, Int] := put(put(v, fst(arg1), snd(arg1)), fst(arg2), snd(arg2))
    var r2 : Map[Int, Int] := put(put(v, fst(arg2), snd(arg2)), fst(arg1), snd(arg1))
    assert map_eq(r1, r2)
  }
}

predicate isMap(r: Ref)
function mapValue(r: Ref): Map[Int, Int]
  requires isMap(r)

field arr_loc: Ref
method emptyArray(n: Int) returns (a: Array)
  requires n >= 0
  ensures len(a) == n && forall i : Int :: i >= 0 && i < n ==> [loc(a, i).arr_loc |-> _]

function toSeq(s: Set[Int]) : Seq[Int]

method createMap() returns (r: Ref)
  requires true
  ensures isMap(r) && mapValue(r) == empty()

method mapPut(r: Ref, k: Int, v: Int)
  requires isMap(r)
  ensures isMap(r) && mapValue(r) == put(old(mapValue(r)), k, v)

field lockMap : Ref


method main(input1: Seq[Int], input2: Seq[Int], secret: Int)
  requires lowEvent && low(input1) && low(input2)
  requires forall e: Int :: e in input1 ==> key_split(key(e))
  requires forall e: Int :: e in input2 ==> !key_split(key(e))
  ensures true
{
  var m : Ref
  m := createMap()
  var l : Lock
  l := newLock[MapLock](lockMap)
  l.lockMap := m
  share[MapLock](l, empty())

  var t1: Thread
  var t2: Thread
  t1 := fork worker(input1, l, secret, true)
  t2 := fork worker(input2, l, secret, false)

  join[worker](t1)
  join[worker](t2)

  acquire[MapLock](l)

  print(l.lockMap)
}


method worker(inputs: Seq[Int], l: Lock, secret: Int, part: Bool)
  requires lowEvent && low(inputs) && lock[MapLock](l, 1/2) && low(part)
  requires forall e: Int :: e in inputs ==> key_split(key(e)) == part
  requires part ? guard[MapLock, Put1](l) : guard[MapLock, Put2](l)
  ensures lock[MapLock](l, 1/2)
{
  var i : Int := 0
  while (i < |inputs|) 
    invariant i >= 0 && i <= |inputs| && low(i) && lock[MapLock](l, 1/2)
    invariant part ? guard[MapLock, Put1](l) : guard[MapLock, Put2](l)
  {
    var k: Int
    var v: Int
    k, v := compute(inputs[i], secret)
    acquire[MapLock](l)
    var tmp : Map[Int, Int]
    tmp := mapValue(l.lockMap) 
    mapPut(l.lockMap, k, v)
    assert mapValue(l.lockMap) == put(tmp, k, v)
    if (part) {
        release[MapLock](l, Put1(pair(k, v)))
    }else{
        release[MapLock](l, Put2(pair(k, v)))
    }

    i := i + 1
    
  }
}

function key(val: Int) : Int

method compute(val: Int, secret: Int) returns (r1: Int, r2: Int)
  ensures low(val) ==> low(r1) && low(r2)
  ensures r1 == key(val)
