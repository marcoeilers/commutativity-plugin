
domain Array {
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function loc_inv_arr(r: Ref): Array
  function loc_inv_index(r: Ref): Int

  axiom all_diff {
    forall a: Array, i: Int :: {loc(a, i)} loc_inv_arr(loc(a, i)) == a && loc_inv_index(loc(a, i)) == i
  }

  axiom length_nonneg {
    forall a: Array :: len(a) >= 0
  }
}

function arr(): Array

field f1: Int
field f2: Int

barrierType Okay {
  in(b, i, n) = ([b.f1 |-[1/n]-> ?bf && bf > 0] && [loc(arr(), i).f2 |-> i])
  totalInAfter(b, i, n) = ((i > 0 ==> [b.f1 |-[i / n]-> ?bf && bf > 0]) && (forall j : Int :: j >= 0 && j < i ==> [loc(arr(), j).f2 |-> j]))
  totalOutAfter(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
  out(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
}

//:: ExpectedOutput(barrier.check.failed.totalin_true:insufficient.permission)
barrierType notTrueAtZero {
  in(b, i, n) = ([b.f1 |-[1/n]-> ?bf && bf > 0] && [loc(arr(), i).f2 |-> i])
  totalInAfter(b, i, n) = ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j]))
  totalOutAfter(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
  out(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
}

//:: ExpectedOutput(barrier.check.failed.in_entails_totalin:insufficient.permission)
barrierType notInToTotalIn {
  in(b, i, n) = [b.f1 |-[1/n]-> ?bf && bf > 0]
  totalInAfter(b, i, n) = ((i > 0 ==> [b.f1 |-[i / n]-> ?bf && bf > 0]) && (forall j : Int :: j >= 0 && j < i ==> [loc(arr(), j).f2 |-> j]))
  totalOutAfter(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
  out(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
}

//:: ExpectedOutput(barrier.check.failed.totalin_implies_totalout:insufficient.permission)
barrierType notTotalInTotalOut {
  in(b, i, n) = ([b.f1 |-[1/n]-> ?bf && bf > 0])
  totalInAfter(b, i, n) = ((i > 0 ==> [b.f1 |-[i / n]-> ?bf && bf > 0]))
  totalOutAfter(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
  out(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
}

//:: ExpectedOutput(barrier.check.failed.totalout_entails_out:insufficient.permission)
barrierType notTotalOutOut {
  in(b, i, n) = [b.f1 |-[1/n]-> ?bf && bf > 0]
  totalInAfter(b, i, n) = i > 0 ==> [b.f1 |-[i / n]-> ?bf && bf > 0]
  totalOutAfter(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0]) : true)
  out(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
}

//:: ExpectedOutput(barrier.check.failed.totalout_entails_out:insufficient.permission)
barrierType notTotalOutOut2 {
  in(b, i, n) = ([b.f1 |-[1/n]-> ?bf && bf > 0] && [loc(arr(), i).f2 |-> i])
  totalInAfter(b, i, n) = ((i > 0 ==> [b.f1 |-[i / n]-> ?bf && bf > 0]) && (forall j : Int :: j >= 0 && j < i ==> [loc(arr(), j).f2 |-> j]))
  totalOutAfter(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
  out(b, i, n) = (i <2 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
}

