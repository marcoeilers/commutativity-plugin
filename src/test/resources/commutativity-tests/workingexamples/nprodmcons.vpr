import "library/pair.vpr"
import "library/unit.vpr"
import "library/either.vpr"
import "library/nat.vpr"
import "library/list.vpr"

function N(): Int      // no of producers
  ensures result > 0
{ 3 }

function M(): Int      // no of consumers
  ensures result > 0
{ 3 }

lockType Channel {
  type Pair[Pair[Multiset[Int], Seq[Multiset[Int]]], Either[Nat, Seq[Int]]]
  invariant(l, v) = [l.queue |-> ?lp && list(lp) &&
                      [l.produced |-> ?prd &&
                        forall i: Int :: i >= 0 && i < M() ==> acc(gloc(l).consumed) // cannot define v == ..., have to write fst(snd(v)) == ...
                                                                                     // then it probably can't prove sequences are equal,
                                                                                     // so it probably can't prove v is unique, and there's no proof script for this
                      v == pair(hi, right(listValue(lp))) ]]
  alpha(v): Pair[Seq[Int], Either[Nat, Seq[Int]]] = v

  actions = [(Prod, Int, unique), (Cons, Unit, unique)]

  action Prod(pv, arg)
    requires low(arg)
  { (let v == (snd(pv)) in
    (is_right(v) ?
      ( pair(fst(pv), (right(Seq(arg) ++ right_val(v)): Either[Nat, Seq[Int]]))) :
      (nat_val(left_val(v)) > 0 ?
        (pair(fst(pv) ++ Seq(arg),   ( left(nat(nat_val(left_val(v)) - 1)): Either[Nat, Seq[Int]]))) :
        (pair(fst(pv) ++ Seq(arg),   ( right(Seq[Int]()): Either[Nat, Seq[Int]])))))
    )}

  action Cons(pv, arg)
    requires true
  {
    ( let v == (snd(pv)) in
    (is_right(v) ?
      (|right_val(v)| > 0 ?
        (pair(fst(pv) ++ Seq(right_val(v)[|right_val(v)|-1]), (right(right_val(v)[..|right_val(v)|-1]): Either[Nat, Seq[Int]]))) :
        pair(fst(pv), (left(nat(0)): Either[Nat, Seq[Int]])) ) :
      pair(fst(pv), (left(nat(nat_val(left_val(v)) + 1)): Either[Nat, Seq[Int]])))
    )
  }

  proof commutativity[Prod, Cons](pv, arg1, arg2) {
    var v: Either[Nat, Seq[Int]]
    v := snd(pv)
    if (is_right(v) && |right_val(v)| > 0) {
      assert (Seq(arg1) ++ right_val(v))[..|(Seq(arg1) ++ right_val(v))|-1] == (Seq(arg1) ++ (right_val(v)[..|right_val(v)|-1]))
    }
  }
}

method enqueue(l: Ref, i: Int)
  requires list(l)
  ensures list(l) && listValue(l) == Seq(i) ++ old(listValue(l))

method dequeue(l: Ref) returns (r: Int)
  requires list(l) && |listValue(l)| > 0
  ensures list(l) && listValue(l) == old(listValue(l)[..|listValue(l)|-1]) 
  ensures r == old(listValue(l)[|listValue(l)|-1])

field queue: Ref
field produced: Multiset[Int]
field consumed: Multiset[Int]
domain Ghost {
  function gloc(r: Ref): Ref
}


method main(inputs: Seq[Int], secret: Int)
  requires lowEvent && low(inputs)
  ensures true
{
  
  var l : Lock
  l := newLock[Channel](queue, history)
  var lst: Ref
  lst := createList()
  l.queue := lst
  l.history := Seq[Int]()
  share[Channel](l, (let es == (Seq[Int]()) in (pair(es,  (right(es) : Either[Nat, Seq[Int]]) ))) )
  var cons : Thread
  var prod : Thread
  prod := fork producer(inputs, l, secret)
  cons := fork consumer(l, |inputs|, secret)
  join[producer](prod)
  var res: Int
  res := join[consumer](cons)
  acquire[Channel](l)
  print(res)
}


method producer(inputs: Seq[Int], l: Lock, secret: Int)
  requires lowEvent && low(inputs) && lock[Channel](l, 1/2) && guard[Channel,Prod](l)
  ensures lock[Channel](l, 1/2)
{
  var i : Int := 0
  while (i < |inputs|) 
    invariant i >= 0 && i <= |inputs| && low(i) && lock[Channel](l, 1/2) && guard[Channel,Prod](l)
  {
    var newVal: Int
    newVal  := compute1(inputs[i], secret)
    acquire[Channel](l)
    
    enqueue(l.queue, newVal)
    
    release[Channel](l, Prod(newVal))
    i := i + 1
  }
}

method consumer(l: Lock, n: Int, secret: Int) returns (res: Int)
  requires lowEvent && n >= 0 && low(n) && lock[Channel](l, 1/2) && guard[Channel,Cons](l) && [l.history |-[1/2]-> ?hi && |hi| == 0]
  ensures lock[Channel](l, 1/2) && [l.history |-[1/2]-> ?hi && res == aggregate(hi)]
{
  var i : Int := 0
  res := INITIAL()
  while (i < n)
    invariant i >= 0 && i <= n && low(i) && lock[Channel](l, 1/2) && guard[Channel,Cons](l)
    invariant [l.history |-[1/2]-> ?hi && res == aggregate(hi)]
  {
    var recVal: Int
    acquire[Channel](l)
    var len : Int
    len := listLength(l.queue)
    while (len == 0)
      invariant lock[Channel](l, 1/4)
      invariant [l.queue |-> ?lp && list(lp) && len == |listValue(lp)| &&
                  [l.history |-[1/2]-> ?hi && locked[Channel](l, pair(hi, (right(listValue(lp)) : Either[Nat, Seq[Int]] ))      )
                  ]
                ]
    {
      release[Channel](l)
      acquire[Channel](l)
      len := listLength(l.queue)
    }
    var ohist : Seq[Int]
    ohist := l.history
    assert true
    recVal := dequeue(l.queue)
    l.history := l.history ++ Seq(recVal)

    release[Channel](l, Cons(unit()))

    res := compute2(res, recVal, secret, ohist)
    i := i + 1
  }
}


method compute1(val: Int, secret: Int) returns (r1: Int)
  ensures low(val) ==> low(r1)

function INITIAL(): Int

function aggregate(s: Seq[Int]): Int
    ensures |s| == 0 ==> result == INITIAL()

method compute2(sum: Int, val: Int, secret: Int, ghost_s: Seq[Int]) returns (r: Int)
  requires sum == aggregate(ghost_s)
  ensures r == aggregate(ghost_s ++ Seq(val))

method print(i: Int)
  requires lowEvent && low(i)
