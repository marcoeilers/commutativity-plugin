import "library/array.vpr"

method print(i: Int)
  requires lowEvent && low(i)


lockType IntLock {
  type Int
  invariant(l, v) = [l.lockCounter |-> ?cp && [cp.val |-> v]]
  alpha(v): Int = 0

   actions = [(Add, Int, duplicable)]

  action Add(v, arg)
    requires true
  { arg }

  noLabels = 2
}




field lockCounter : Ref
field val: Int


method main()
  requires lowEvent
{
  var ctr : Ref
  ctr := new(val)
  ctr.val := 0
  var l : Lock
  l := new(lockCounter)
  l.lockCounter := ctr
  share[IntLock](l, 0)
  var t1: Thread
  var t2: Thread
  assert intervalSet(0, 2) == Set(0, 1)
  assert Set(0) union Set(1) == Set(0, 1)
  assert Multiset[Int]() union Multiset[Int]() == Multiset[Int]()
  split[IntLock,Add](l, Set(0), Set(1), Multiset[Int](), Multiset[Int]())
  t1 := fork worker(l, 0)
  t2 := fork worker(l, 1)
  join[worker](t1)
  join[worker](t2)
  merge[IntLock, Add](l, Set(0), Set(1))

  unshare[IntLock](l)

  // should fail
  //:: ExpectedOutput(call.precondition:assertion.false)
  print(l.lockCounter.val)

}


method worker(l: Lock, lbl: Int)
  requires lowEvent && sguard[IntLock,Add](l, Set(lbl)) && sguardArgs[IntLock,Add](l, Set(lbl)) == Multiset[Int]()
  ensures sguard[IntLock,Add](l, Set(lbl)) && allPre[IntLock, Add](sguardArgs[IntLock,Add](l, Set(lbl)))
{

    var v: Int
    v := lbl
    with[IntLock] l performing Add(v) at lbl {
        l.lockCounter.val := v
    }

}
