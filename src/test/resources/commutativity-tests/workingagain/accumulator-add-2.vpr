domain Array {
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function loc_inv_arr(r: Ref): Array
  function loc_inv_index(r: Ref): Int

  axiom all_diff {
    forall a: Array, i: Int :: {loc(a, i)} loc_inv_arr(loc(a, i)) == a && loc_inv_index(loc(a, i)) == i
  }

  axiom length_nonneg {
    forall a: Array :: len(a) >= 0
  }
}

field arr_loc: Ref

method emptyArray(n: Int) returns (a: Array)
  requires n >= 0
  ensures len(a) == n && forall i : Int :: i >= 0 && i < n ==> acc(loc(a, i).arr_loc)

////

domain MyMap[T,V0] {
  function empty(): MyMap[T,V0]
  function keys(m: MyMap[T,V0]): Set[T]
  function get(m: MyMap[T,V0], k: T) : V0
  function put(m: MyMap[T,V0], k: T, v: V0): MyMap[T,V0]
  function map_eq(m1: MyMap[T,V0], m2: MyMap[T,V0]) : Bool
  function map_merge(m1: MyMap[T,V0], m2: MyMap[T,V0]): MyMap[T, V0]

  function singleton(k: T, v: V0): MyMap[T, V0]

  axiom equality_def {
    forall m1: MyMap[T,V0], m2: MyMap[T,V0] :: {map_eq(m1, m2)}
        map_eq(m1, m2) == (keys(m1) == keys(m2) && forall k: T :: k in keys(m1) ==> get(m1, k) == get(m2, k))
  }

  axiom equality_extensional {
    forall m1: MyMap[T,V0], m2: MyMap[T,V0] :: {map_eq(m1, m2)} map_eq(m1, m2) ==> m1 == m2
  }

  axiom empty_def {
    keys((empty(): MyMap[T, V0])) == Set[T]()
  }

  axiom single_def {
    (forall k: T, v: V0 :: keys(singleton(k, v)) == Set(k))
    &&
    (forall k: T, v: V0 :: get(singleton(k, v), k) == v)
  }

  axiom merge_def {
    (forall m1: MyMap[T, V0], m2: MyMap[T, V0] :: {map_merge(m1, m2)} keys(m1) intersection keys(m2) == Set[T]() ==>
      keys(map_merge(m1, m2)) == keys(m1) union keys(m2) && forall k: T:: k in keys(map_merge(m1, m2)) ==> get(map_merge(m1, m2), k) == (k in keys(m1) ? get(m1, k) : get(m2, k)) )
  }

  axiom put_keys {
    forall m: MyMap[T,V0], k: T, v: V0 :: {keys(put(m, k, v))} keys(put(m, k, v)) == keys(m) union Set(k)
  }

  axiom put_get {
    forall m: MyMap[T,V0], k1: T, k2: T, v: V0 :: {get(put(m, k1, v), k2)} get(put(m, k1, v), k2) == (k1 == k2 ? v : get(m, k2))
  }
}

////////////////////


field key: Int
field value: Int
field next: Ref
field arr: Array
function nBuckets(): Int
{ 4 }

predicate ListMap(r: Ref) {
  (acc(r.key) && acc(r.value) && acc(r.next) && (r.next != null ==> ListMap(r.next) && !ListMap_contains(r.next, r.key)))
}

function ListMap_contains(r: Ref, k: Int): Bool
  requires acc(ListMap(r), 1/100)
  ensures result == k in keys(ListMap_mapValue(r))
{
  unfolding acc(ListMap(r), 1/100) in (r.next == null ? false : r.key == k ? true : ListMap_contains(r.next, k))
}

function ListMap_get(r: Ref, k: Int): Int
  requires acc(ListMap(r), 1/100)
  requires ListMap_contains(r, k)
  ensures result == get(ListMap_mapValue(r), k)
{
  unfolding acc(ListMap(r), 1/100) in (r.key == k ? r.value : ListMap_get(r.next, k))
}

function ListMap_mapValue(r: Ref): MyMap[Int, Int]
  requires acc(ListMap(r), 1/100)
{
  unfolding acc(ListMap(r), 1/100) in (r.next == null ? empty() : put(ListMap_mapValue(r.next), r.key, r.value))
}

method createListMap() returns (r: Ref)
{
  r := null
}

method ListMap_put(r: Ref, k: Int, v: Int)
  requires ListMap(r)
  ensures ListMap(r) && (ListMap_mapValue(r) == put(old(ListMap_mapValue(r)), k, v))
{
  if (ListMap_contains(r, k)) {
    unfold ListMap(r)
    if (r.key == k) {
      r.value := v
      fold ListMap(r)
      //assert keys(ListMap_mapValue(res)) == keys(put(old(ListMap_mapValue(r)), k, v))
      //assert get(ListMap_mapValue(res), k) == get(put(old(ListMap_mapValue(r)), k, v), k)
      assert map_eq(ListMap_mapValue(r), put(old(ListMap_mapValue(r)), k, v))
    }else{
      ListMap_put(r.next, k, v)
      fold ListMap(r)
      assert map_eq(ListMap_mapValue(r), put(old(ListMap_mapValue(r)), k, v))
    }
  }else{
    unfold ListMap(r)
    var newNode: Ref
    newNode := new(key, value, next)
    if (r.next == null){
      r.next := newNode
      newNode.next := null
      r.key := k
      r.value := v
    } else {
      newNode.next := r.next
      newNode.key := k
      newNode.value := v
      r.next := newNode
    }
    fold ListMap(newNode)
    fold ListMap(r)
    assert map_eq(ListMap_mapValue(r), put(old(ListMap_mapValue(r)), k, v))
  }
}

// array of buckets?

function hashCode(k: Int): Int
  ensures result >= 0 && result < nBuckets()

predicate isMap(r: Ref) {
  acc(r.arr) && len(r.arr) == nBuckets() &&
  forall i: Int :: {loc(r.arr, i)} i >= 0 && i < len(r.arr) ==> acc(loc(r.arr, i).arr_loc) && ListMap(loc(r.arr, i).arr_loc) &&
    (forall k: Int :: ListMap_contains(loc(r.arr, i).arr_loc, k) ==> hashCode(k) == i) &&
    (forall k: Int :: k in keys(ListMap_mapValue(loc(r.arr, i).arr_loc)) ==> hashCode(k) == i)
}

function mapValue(r: Ref): MyMap[Int, Int]
  requires acc(isMap(r), 1/100)
{
  unfolding acc(isMap(r), 1/100) in
  map_merge(map_merge(map_merge(ListMap_mapValue(loc(r.arr, 0).arr_loc), ListMap_mapValue(loc(r.arr, 1).arr_loc)), ListMap_mapValue(loc(r.arr, 2).arr_loc)), ListMap_mapValue(loc(r.arr, 3).arr_loc))
}

method createMap() returns (r: Ref)
  ensures isMap(r) && mapValue(r) == empty()
{
  r := new(arr)
  var newArr : Array
  newArr := emptyArray(nBuckets())
  r.arr := newArr
  var j: Int
  j := 0
  while (j < nBuckets())
    invariant j >= 0 && j <= nBuckets()
    invariant forall i: Int :: i >= 0 && i < j ==> acc(loc(r.arr, i).arr_loc) && ListMap(loc(r.arr, i).arr_loc) && forall k: Int :: ListMap_contains(loc(r.arr, i).arr_loc, k) ==> hashCode(k) == i
  {
    var newListMap: Ref
    newListMap := createListMap()
    loc(r.arr, j).arr_loc := newListMap
  }

  fold isMap(r)
}

method mapPut(r: Ref, k: Int, v: Int)
  requires isMap(r)
  ensures isMap(r) && mapValue(r) == put(old(mapValue(r)), k, v)
{
  unfold isMap(r)
  var hash: Int
  hash := hashCode(k)
  var bucket: Ref
  bucket := loc(r.arr, hash).arr_loc
  ListMap_put(bucket, k, v)
  fold isMap(r)
  assert map_eq(mapValue(r), put(old(mapValue(r)), k, v))
}

method mapGet(r: Ref, k: Int) returns (contained: Bool, vl: Int)
  requires acc(isMap(r), 1/100)
  ensures acc(isMap(r), 1/100) && contained == (k in keys(mapValue(r))) && (contained ==> vl == get(mapValue(r), k))
{
  var hash: Int
  hash := hashCode(k)
  var bucket: Ref
  unfold acc(isMap(r), 1/100)
  bucket := loc(r.arr, hash).arr_loc
  if (ListMap_contains(bucket, k)) {
    contained := true
    vl := ListMap_get(bucket, k)
  }else {
    contained := false
  }
  fold acc(isMap(r), 1/100)
}

//// until here
// households

method print(i: Int)
  requires lowEvent && low(i)

method compute(vl: Ref) returns (r1: Int)
  requires isMap(vl) && nTargets() in keys(mapValue(vl)) && low(get(mapValue(vl), nTargets()))
  ensures patient(vl) && low(r1)
{
    var tmp: Bool
    tmp, r1 := mapGet(vl, nTargets())
}


lockType CounterLock {
  type Int
  invariant(l, v) = [l.lockCounter |-> ?cp && [cp.val |-> v]]
  alpha(v): Int = v

    actions = [(Add, Int, duplicable)]

      action Add(v, arg)
        requires low(arg)
      { v + arg }

  noLabels = N()
}

predicate joinableArrayEntry(rec: Ref, inputs: Seq[Ref], l: Ref, lbl: Int) {
  [rec.arr_loc |-> ?al && joinable[worker](al, inputs, l, lbl)]
}


field lockCounter : Ref
field val: Int

function N(): Int
    ensures result > 1

function nTargets(): Int

define patient(r) (
    isMap(r) && nTargets() in keys(mapValue(r)) && low(get(mapValue(r), nTargets()))
)


method main(inputs: Seq[Seq[Ref]])
  requires lowEvent && low(|inputs|) && |inputs| == N()
  requires forall ip: Int :: ip >= 0 && ip < N() ==> low(|inputs[ip]|)
  requires forall ip: Int, jp: Int :: ip >= 0 && ip < N() && jp >= 0 && jp < |inputs[ip]| ==> patient(inputs[ip][jp])
{
  var ctr : Ref
  ctr := new(val)
  ctr.val := 0
  var l : Lock
  l := new(lockCounter)
  l.lockCounter := ctr
  share[CounterLock](l, 0)
  var i : Int := 0
  var threads : Array
  threads := emptyArray(|inputs|)
  while (i < |inputs|)
    invariant i >= 0 && i <= |inputs| && low(i)
    invariant forall j : Int :: j >= 0 && j < |inputs| && j >= i ==> [loc(threads, j).arr_loc |-> _]
    invariant forall j : Int :: j >= 0 && j < i ==> joinableArrayEntry(loc(threads, j), inputs[j], l, j)
    invariant sguard[CounterLock,Add](l, intervalSet(i, N())) && sguardArgs[CounterLock, Add](l, intervalSet(i, N())) == Multiset[Int]()
    invariant forall ip: Int, jp: Int :: ip >= i && ip < N() && jp >= 0 && jp < |inputs[ip]| ==> patient(inputs[ip][jp])
  {
    var t: Thread
    assert Set(i) union intervalSet(i+1, N()) == intervalSet(i, N())
    split[CounterLock,Add](l, Set(i), intervalSet(i+1, N()), Multiset[Int](), Multiset[Int]())
    t := fork worker(inputs[i], l, i)
    loc(threads, i).arr_loc := t
    fold joinableArrayEntry(loc(threads, i), inputs[i], l, i)
    i := i + 1
  }
  
  i := 0
  while (i < |inputs|)
    invariant i >= 0 && i <= |inputs| && low(i)
    invariant forall j : Int :: j >= 0 && j < |inputs| && j >= i ==> joinableArrayEntry(loc(threads, j), inputs[j], l, j)
    invariant forall j : Int :: j >= 0 && j < i ==> [loc(threads, j).arr_loc |-> _] 
    invariant sguard[CounterLock,Add](l, intervalSet(0, i)) && allPre[CounterLock, Add](sguardArgs[CounterLock,Add](l, intervalSet(0, i)))
  {
    unfold joinableArrayEntry(loc(threads, i), inputs[i], l, i)
    join[worker](loc(threads, i).arr_loc)
    assert Set(i) union intervalSet(0, i) == intervalSet(0, i + 1)
    merge[CounterLock, Add](l, Set(i), intervalSet(0, i))
    i := i + 1
  }
  unshare[CounterLock](l)


  print(l.lockCounter.val)

}


method worker(inputs: Seq[Ref], l: Lock, lbl: Int)
  requires lowEvent && low(|inputs|) && sguard[CounterLock,Add](l, Set(lbl)) && sguardArgs[CounterLock,Add](l, Set(lbl)) == Multiset[Int]()
  requires forall jp: Int :: jp >= 0 && jp < |inputs| ==> patient(inputs[jp])
  ensures sguard[CounterLock,Add](l, Set(lbl)) && allPre[CounterLock, Add](sguardArgs[CounterLock,Add](l, Set(lbl)))
{
  var i : Int := 0
  while (i < |inputs|) 
    invariant i >= 0 && i <= |inputs| && low(i) && sguard[CounterLock,Add](l, Set(lbl)) && allPre[CounterLock, Add](sguardArgs[CounterLock,Add](l, Set(lbl)))
    invariant forall jp: Int :: jp >= 0 && jp < |inputs| ==> patient(inputs[jp])
  {
    var v: Int
    v := compute(inputs[i])
    with[CounterLock] l performing Add(v) at lbl {
        l.lockCounter.val := l.lockCounter.val + v
    }

    i := i + 1
  }
}
