
domain Array {
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function loc_inv_arr(r: Ref): Array
  function loc_inv_index(r: Ref): Int

  axiom all_diff {
    forall a: Array, i: Int :: {loc(a, i)} loc_inv_arr(loc(a, i)) == a && loc_inv_index(loc(a, i)) == i
  }

  axiom length_nonneg {
    forall a: Array :: len(a) >= 0
  }
}

function arr(): Array

field f1: Int
field f2: Int

barrierType Okay {
  in(b, i, n) = ([b.f1 |-[1/n]-> ?bf && bf > 0] && [loc(arr(), i).f2 |-> i])
  totalInAfter(b, i, n) = ((i > 0 ==> [b.f1 |-[i / n]-> ?bf && bf > 0]) && (forall j : Int :: j >= 0 && j < i ==> [loc(arr(), j).f2 |-> j]))
  totalOutAfter(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
  out(b, i, n) = (i == 0 ? ([b.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < n ==> [loc(arr(), j).f2 |-> ?jv && jv >= j])) : true)
}

method okayCreateBarrier() returns (b0 : Barrier)
  ensures barrier[Okay](b0, 1, 2) && barrier[Okay](b0, 0, 2)
{
  b0 := newBarrier[Okay](2)(f1, f2)
}

method createBarrierSmoke() returns (b0 : Barrier)
  //:: ExpectedOutput(postcondition.violated:insufficient.permission)
  ensures barrier[Okay](b0, 1, 2) && barrier[Okay](b0, 0, 2) && barrier[Okay](b0, 0, 2)
{
  b0 := newBarrier[Okay](2)(f1, f2)
}

method createBarrierNonPositive(n: Int) returns (b0 : Barrier)
  ensures barrier[Okay](b0, 1, 2) && barrier[Okay](b0, 0, 2)
{
  //:: ExpectedOutput(new.barrier.failed:assertion.false)
  b0 := newBarrier[Okay](n)(f1, f2)
}

method waitOkay(b0 : Barrier)
  requires barrier[Okay](b0, 0, 6) && [b0.f1 |-[1/6]-> ?bf && bf > 0] && [loc(arr(), 0).f2 |-> 0]
  ensures barrier[Okay](b0, 0, 6) && ([b0.f1 |-> ?mybf && mybf >= 0] && (forall j : Int :: j >= 0 && j < 6 ==> [loc(arr(), j).f2 |-> ?jv && jv >= j]))
{
  wait[Okay](b0, 0, 6)
}

method waitSmoke(b0 : Barrier)
  requires barrier[Okay](b0, 0, 6) && [b0.f1 |-[1/6]-> ?bf && bf > 0] && [loc(arr(), 0).f2 |-> 0]
  //:: ExpectedOutput(postcondition.violated:assertion.false)
  ensures false
{
  wait[Okay](b0, 0, 6)
}

method waitNoBarrierAssertion(b0 : Barrier)
  requires [b0.f1 |-[1/6]-> ?bf && bf > 0] && [loc(arr(), 0).f2 |-> 3]
{
  //:: ExpectedOutput(wait.failed:insufficient.permission)
  wait[Okay](b0, 0, 6)
}

method waitNoIn(b0 : Barrier)
  requires barrier[Okay](b0, 0, 6)
{
  //:: ExpectedOutput(wait.failed:insufficient.permission)
  wait[Okay](b0, 0, 6)
}



