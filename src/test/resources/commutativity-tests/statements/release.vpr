field f: Int

lockType Okay {
  type Int
  invariant(l, v) = [l.f |-> ?fv && v == 2*fv && v >= 0]
  alpha(v): Int = v

  actions = [(Add,Int,unique)]

  action Add(v, a)
    requires low(a)
  { (v + a) }
}

method okayChange(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && lock[Okay](l, 1/2) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0] && guard[Okay,Add](l)
  ensures lock[Okay](l, 1/2)
{
  assume newVal == oldVal + ar
  assume low(ar) && ar > 0
  release[Okay](l, Add(ar))
}

method okaySmoke(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && lock[Okay](l, write) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0] && guard[Okay,Add](l)
  //:: ExpectedOutput(postcondition.violated:assertion.false)
  ensures false
{
  assume newVal == oldVal + ar
  assume low(ar) && ar > 0
  release[Okay](l, Add(ar))
}

method relationalPreNotFulfilled(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && lock[Okay](l, write) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0] && guard[Okay,Add](l)
{
  assume newVal == oldVal + ar
  assume ar > 0
  //:: ExpectedOutput(release.failed:assertion.false)
  release[Okay](l, Add(ar))
}

method wrongValue(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && lock[Okay](l, write) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0] && guard[Okay,Add](l)
{
  assume low(ar) && ar > 0
  //:: ExpectedOutput(release.failed:assertion.false)
  release[Okay](l, Add(ar))
}

method noGuard(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && lock[Okay](l, write) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0]
{
  assume newVal == oldVal + ar
  assume low(ar) && ar > 0
  //:: ExpectedOutput(release.failed:assertion.false)
  release[Okay](l, Add(ar))
}

method noLocked(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && lock[Okay](l, write) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0] && guard[Okay,Add](l)
{
  assume newVal == oldVal + ar
  assume low(ar) && ar > 0
  //:: ExpectedOutput(release.failed:insufficient.permission)
  release[Okay](l, Add(ar))
}

method noInv(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && lock[Okay](l, write) && locked[Okay](l, oldVal) && guard[Okay,Add](l)
{
  assume newVal == oldVal + ar
  assume low(ar) && ar > 0
  //:: ExpectedOutput(release.failed:insufficient.permission)
  release[Okay](l, Add(ar))
}

method noLock(l: Lock, oldVal : Int, newVal: Int, ar: Int)
  requires lowEvent && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0] && guard[Okay,Add](l)
{
  assume newVal == oldVal + ar
  assume low(ar) && ar > 0
  //:: ExpectedOutput(release.failed:assertion.false)
  release[Okay](l, Add(ar))
}

method okayUnchanged(l: Lock, oldVal : Int, newVal: Int)
  requires lock[Okay](l, write) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0]
  ensures lock[Okay](l, write)
{
  assume newVal == oldVal
  release[Okay](l)
}

method unchangedSmoke(l: Lock, oldVal : Int, newVal: Int)
  requires lock[Okay](l, write) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0]
  //:: ExpectedOutput(postcondition.violated:assertion.false)
  ensures false
{
  assume newVal == oldVal
  release[Okay](l)
}

method unchangedUnclear(l: Lock, oldVal : Int, newVal: Int)
  requires lock[Okay](l, write) && locked[Okay](l, oldVal) && [l.f |-> ?fv && newVal == 2*fv && newVal >= 0] && guard[Okay,Add](l)
  ensures lock[Okay](l, write)
{
  //:: ExpectedOutput(release.failed:assertion.false)
  release[Okay](l)
}

method releaseNewLock() returns (l: Lock)
  requires lowEvent
{
  l := newLock[Okay](f)
  l.f := 23
  //:: ExpectedOutput(release.failed:assertion.false)
  release[Okay](l)
}