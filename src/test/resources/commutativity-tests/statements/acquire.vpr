field f: Int

lockType Okay {
  type Int
  invariant(l, v) = [l.f |-> ?fv && v == 2*fv && v >= 0]
  alpha(v): Int = v
  histInvariant(v0, v1) = v0 <= v1

  actions = [(Add,Int,unique)]

  action Add(v, a)
    requires low(a) && a > 0
  { (v + a) }
}

method okay(l: Lock) returns (r: Int)
  requires lock[Okay](l, write)
  ensures lock[Okay](l, write) && [l.f |-> ?fv && r == 2*fv && r >= 0 && low(r)] && locked[Okay](l, r)
{
  acquire[Okay](l)
  r := 2*l.f
}

method okayNoFull(l: Lock) returns (r: Int)
  requires lock[Okay](l, 1/2)
  ensures lock[Okay](l, 1/2) && [l.f |-> ?fv && r == 2*fv && r >= 0] && locked[Okay](l, r)
{
  acquire[Okay](l)
  r := 2*l.f
}

method noFullAssertLow(l: Lock) returns (r: Int)
  requires lock[Okay](l, 1/2)
  //:: ExpectedOutput(postcondition.violated:assertion.false)
  ensures lock[Okay](l, 1/2) && [l.f |-> ?fv && r == 2*fv && r >= 0 && low(r)] && locked[Okay](l, r)
{
  acquire[Okay](l)
  r := 2*l.f
}

method smoke(l: Lock) returns (r: Int)
  requires lock[Okay](l, write)
  //:: ExpectedOutput(postcondition.violated:assertion.false)
  ensures false
{
  acquire[Okay](l)
  r := 2*l.f
}

method noLock(l: Lock) returns (r: Int)
{
  //:: ExpectedOutput(acquire.failed:assertion.false)
  acquire[Okay](l)
  r := 2*l.f
}

